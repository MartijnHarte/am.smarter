'use strict';

var Socket = require( 'net' ).Socket
    , log = require( 'debug' )( 'discover' )
    , debug = require( 'debug' )( 'discover:debug' )
    , os = require( 'os' )
    , ifaces = os.networkInterfaces();

var sys = require('util');
var PORT = 2000
var HELLO_APP = 'HELLOAPP'
var HELLO_KETTLE = 'HELLOKETTLE\n'
var kettle = null;

var checkForKettle = function ( ip, portDetails, eventEmitter ) {
    debug( 'Checking IP ' + ip + ' for kettles', portDetails.state )
    if ( 'open' !== portDetails.state ) return
    var client = new Socket()
    client.setEncoding( 'ascii' )
    client.setNoDelay()
    client.connect( PORT, ip, function () {
        debug( 'Connected to ' + ip )
        var found = false
        var timeout = setTimeout( function () {
            if ( false === found ) client.end()
            log( 'Timeout on IP address ' + ip )
        }, 1500 )
        client.once( 'data', function ( response ) {
            if ( response.indexOf( HELLO_APP ) !== -1 ) {
                log( 'Have found a kettle on IP ' + ip )

                eventEmitter.emit( 'found_device', client );
            }
            found = true
            clearTimeout( timeout )
        } )
        client.write( HELLO_KETTLE )
    } )
}

/**
 * This method creates a socket connection to host@port and returns
 * whether this device is listening on port or not.
 * @param port
 * @param host
 * @param checkPort
 * @param callback2
 */
var connectSocket = function ( port, host, eventEmitter, callback ) {
    var socket = new Socket(), status = null, error = null;

    // If no response, assume port is not listening
    socket.setTimeout( 1500 );

    // Socket connection established, port is open
    socket.on( 'connect', function () {
        status = 'open';
        socket.end();
    } );

    // When connection timeout destroy and return
    socket.on( 'timeout', function () {
        status = 'closed';
        error = true;
        socket.destroy();
    } );

    // On error, set status to closed
    socket.on( 'error', function () {
        status = 'closed';
    } );

    // When a socket is closed
    socket.on( 'close', function () {
        debug( 'Found IP address ' + host )

        // If port is open
        if ( status === 'open' ) {
            // Check if found device is a kettle
            checkForKettle( host, { state: status }, eventEmitter );
            eventEmitter.emit('close');

            // Callback for testing purposes
            if ( callback ) callback( status )
        }
        else {
            eventEmitter.emit('close');

            // Callback for testing purposes
            if ( callback ) callback( status )
        }
    } );

    // Connect socket to host@port
    socket.connect( port, host );
}

/**
 * This method loops over local interfaces and finds a list
 * of IP addresses within the same subnet
 * @param callback
 */
var discover = function ( eventEmitter, callback ) {
    log( 'Performing discovery' )

    var ipAddress = null;
    for ( var dev in ifaces ) {
        if ( dev !== 'en1' && dev !== 'en0' ) {
            continue;
        }
        for(var i = 0; i < ifaces[ dev ].length; i++){
            var details = ifaces[dev][i]
            if ( details.family === 'IPv4' ) {
                ipAddress = details.address;
            }
        }
    }

    // Set default
    if(!ipAddress) ipAddress = '192.168.1.42';

    // Create LAN address
    var lan = ipAddress.substr( 0, ipAddress.lastIndexOf( '.' ) );

    // Set kettle to null as new discovery is started
    kettle = null;

    // Counter to keep track when done
    var checkedIPs = 0;
    var possibleIPS = 0;

    // When connection was checked register this
    eventEmitter.on('close', function(){
        checkedIPs++

        // If all possibilities are checked
        if(checkedIPs === possibleIPS){

            // Emit done
            eventEmitter.emit('done');
        }
    });

    // Iterate all possible ips within subnet
    for ( var j = 0; j < 255; j++ ) {
        possibleIPS++;

        // Try to set up a socket connection with target
        connectSocket( PORT, lan + '.' + j, eventEmitter, callback )
    }
};

// Export all for testing purposes
module.exports = {
    discover: discover,
    connectSocket: connectSocket
}
